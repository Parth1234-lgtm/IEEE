<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Adaptive UI – Demo Article</title>
  <style>
    /* ============================================================
       Demo page baseline styles
       ============================================================ */
    :root {
      --bg: #f4f5f7;
      --text: #24292f;
      --muted: #656d76;
      --surface: #ffffff;
      --border: #d0d7de;
      --accent: #1a73e8;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.6;
      font-size: 16px;
    }

    /* --- Navigation --- */
    nav[data-adapt-nav] {
      background: #24292f;
      color: #fff;
      padding: 12px 24px;
      display: flex;
      align-items: center;
      gap: 24px;
      font-size: 14px;
    }
    nav a { color: #ccc; text-decoration: none; }
    nav a:hover { color: #fff; }
    nav .brand { font-weight: 700; font-size: 16px; color: #fff; }

    /* --- Layout --- */
    .page-layout {
      display: grid;
      grid-template-columns: 1fr 280px;
      gap: 24px;
      max-width: 1100px;
      margin: 24px auto;
      padding: 0 24px;
    }

    /* --- Main content --- */
    main[data-adapt-content] {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 32px 36px;
    }
    main h1 {
      font-size: 28px;
      margin-bottom: 6px;
    }
    main .meta {
      font-size: 13px;
      color: var(--muted);
      margin-bottom: 20px;
    }
    main h2 {
      font-size: 20px;
      margin: 28px 0 10px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }
    main p {
      margin-bottom: 14px;
      color: #3b3b3b;
    }

    /* --- Sidebar --- */
    aside[data-adapt-aside] {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .sidebar-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 16px;
    }
    .sidebar-card h3 {
      font-size: 14px;
      margin-bottom: 8px;
      color: var(--accent);
    }
    .sidebar-card p, .sidebar-card li {
      font-size: 13px;
      color: var(--muted);
      line-height: 1.5;
    }
    .sidebar-card ul {
      padding-left: 18px;
    }

    /* --- Footer --- */
    footer[data-adapt-footer] {
      max-width: 1100px;
      margin: 32px auto;
      padding: 16px 24px;
      text-align: center;
      font-size: 12px;
      color: var(--muted);
      border-top: 1px solid var(--border);
    }

    @media (max-width: 768px) {
      .page-layout {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>

  <!-- Navigation (will be dimmed in adaptive mode) -->
  <nav data-adapt-nav>
    <span class="brand">ResearchHub</span>
    <a href="#">Papers</a>
    <a href="#">Datasets</a>
    <a href="#">Experiments</a>
    <a href="#">Community</a>
  </nav>

  <div class="page-layout">

    <!-- Main content area (adaptations target this) -->
    <main data-adapt-content>
      <h1>How Attention Signals Can Drive Adaptive Interfaces</h1>
      <div class="meta">Published Feb 5 2026 &middot; 8 min read &middot; Dr. A. Simmons, UX Cognition Lab</div>

      <p>
        The way people read on screens differs fundamentally from how they read print. Eye-tracking
        studies consistently show that online readers adopt an F-shaped scanning pattern: they read
        the first few lines almost entirely, then progressively scan less of each subsequent line. This
        behaviour means that static page layouts waste significant cognitive bandwidth by treating all
        content sections equally.
      </p>

      <p>
        Adaptive user interfaces attempt to bridge this gap by observing how a reader actually engages
        with a page and adjusting the presentation in real time. Rather than relying on explicit
        preferences, the system infers attentional state from low-cost browser signals such as scroll
        velocity, viewport dwell time, and reread patterns.
      </p>

      <section data-adapt-section="scroll-velocity">
        <h2>Scroll Velocity as a Proxy for Engagement</h2>

        <p>
          Scroll speed is one of the simplest signals to capture, yet it carries meaningful information.
          Rapid, continuous scrolling typically indicates skimming: the user is searching for a target
          section rather than absorbing content. In contrast, slow or intermittent scrolling suggests
          active reading, where the user pauses to process information before advancing.
        </p>

        <p>
          By monitoring scroll velocity over a sliding window, an adaptive system can classify the
          reader's current intent in near real time. When skimming is detected, the UI might collapse
          less-relevant sections or surface a table of contents to aid navigation. When deep reading
          is detected, the system can optimise typography — increasing font size, widening line spacing,
          and narrowing the content column to reduce saccade length.
        </p>

        <p>
          A key design consideration is latency. Users are highly sensitive to layout shifts that occur
          while they are reading. Adaptations should therefore be applied during natural transition
          points — for example, when the user pauses scrolling or reaches a new section heading.
        </p>
      </section>

      <section data-adapt-section="dwell-time">
        <h2>Dwell Time and Section-Level Relevance</h2>

        <p>
          Dwell time — the duration a particular element remains within the viewport — provides a
          section-level measure of interest. Using the Intersection Observer API, a content script can
          track exactly how long each paragraph, heading, or figure is visible without any performance
          penalty.
        </p>

        <p>
          Sections that accumulate high dwell time relative to their word count are likely important to
          the reader. The system can respond by visually anchoring these sections: adding subtle
          highlights, pinning them to a "key points" sidebar, or ensuring they appear in a generated
          summary. Conversely, sections with near-zero dwell time can be progressively de-emphasised,
          reducing visual clutter without removing content entirely.
        </p>

        <p>
          This approach respects user autonomy — nothing is hidden, only re-weighted. The reader can
          always scroll back and access every section in full. The adaptive layer is an enhancement, not
          a filter.
        </p>
      </section>

      <section data-adapt-section="rereading">
        <h2>Detecting Rereading Behaviour</h2>

        <p>
          Rereading is a particularly strong signal. When a user scrolls backward to revisit content
          they have already seen, it typically means one of two things: the passage was confusing and
          requires a second pass, or the passage contained critical information worth memorising.
        </p>

        <p>
          A simple but effective heuristic tracks which vertical zones of the page have entered the
          viewport. If the user scrolls upward into a previously-viewed zone, the system records a
          "reread event." Tracking reread frequency over time yields a per-minute metric that
          correlates with task difficulty or content complexity.
        </p>

        <p>
          When elevated reread rates are detected, the adaptive system can proactively improve
          readability: inserting a summary block at the top of the article, chunking long paragraphs
          into distinct card elements, or adjusting contrast ratios to reduce eye strain.
        </p>
      </section>

      <section data-adapt-section="adaptation-plan">
        <h2>From Signals to Adaptation Plan</h2>

        <p>
          In a production system, the collected signals would feed into a lightweight model — possibly
          a rule engine or a small on-device ML classifier — that outputs an Adaptation Plan. This plan
          is a structured JSON document describing which adaptations to apply, to which DOM elements,
          and with what parameters.
        </p>

        <p>
          For demonstration purposes, a mock plan can be hardcoded in the browser extension's
          background service worker. This allows the full pipeline to be validated end to end without
          requiring an external backend or API calls. The content script receives the plan via message
          passing and applies it to the current page DOM.
        </p>

        <p>
          The separation between signal collection, plan generation, and plan execution is deliberate.
          It creates a clean architectural boundary that allows each stage to be independently tested
          and improved. Future iterations could swap the mock plan for a live model without touching
          the adaptation rendering code.
        </p>
      </section>

      <section data-adapt-section="privacy-performance">
        <h2>Privacy and Performance Considerations</h2>

        <p>
          All signal processing occurs locally within the browser extension. No scroll data, dwell
          times, or behavioural metrics leave the user's device. The extension stores only aggregate
          statistics in chrome.storage.local — individual scroll events are processed in memory and
          discarded.
        </p>

        <p>
          Performance impact is minimal. Scroll listeners use requestAnimationFrame gating to avoid
          layout thrashing. The Intersection Observer API is natively optimised by the browser engine.
          Metric flushing occurs on a 500ms interval, well below the threshold of perceptible jank.
          The total additional CPU usage is negligible compared to typical web page rendering.
        </p>
      </section>

      <section data-adapt-section="conclusion">
        <h2>Conclusion</h2>

        <p>
          Attention-adaptive interfaces represent a shift from "one layout fits all" to
          "the layout fits the reader." By leveraging signals that browsers already generate — scroll
          position, element visibility, navigation direction — we can build responsive reading
          environments that reduce cognitive load and improve comprehension, all without invasive
          tracking or external dependencies.
        </p>

        <p>
          The prototype described here demonstrates that the core pipeline — signals to plan to UI
          change — is technically feasible with standard web extension APIs and minimal code. The next
          step is connecting real signal classifiers and measuring the impact on reading comprehension
          in controlled user studies.
        </p>
      </section>
    </main>

    <!-- Sidebar (will be dimmed in adaptive mode) -->
    <aside data-adapt-aside>
      <div class="sidebar-card">
        <h3>About This Demo</h3>
        <p>
          This page is a controlled demo for the Attention-Adaptive UI extension.
          Load the extension, then use the popup toggle to switch between
          <strong>Baseline</strong> and <strong>Adaptive</strong> modes.
        </p>
      </div>

      <div class="sidebar-card">
        <h3>Signals Collected</h3>
        <ul>
          <li>Scroll velocity &amp; direction</li>
          <li>Viewport dwell time per section</li>
          <li>Reread events (upward scroll)</li>
          <li>Zoom oscillations (Ctrl+scroll)</li>
          <li>Large scroll jumps</li>
        </ul>
      </div>

      <div class="sidebar-card">
        <h3>User States</h3>
        <ul>
          <li><strong>Readability:</strong> font boost, contrast, highlights, clutter dimming</li>
          <li><strong>Overload:</strong> TL;DR, collapsed sections, heading emphasis, density reduction</li>
        </ul>
      </div>

      <div class="sidebar-card">
        <h3>Related Reading</h3>
        <p>Nielsen, J. (2006). "F-Shaped Pattern for Reading Web Content." NN/g.</p>
        <p>Buscher, G. et al. (2012). "Attentive Documents." Int. J. HCI.</p>
      </div>
    </aside>
  </div>

  <!-- Footer (will be dimmed in adaptive mode) -->
  <footer data-adapt-footer>
    &copy; 2026 UX Cognition Lab &middot; This is a static demo page for the Attention-Adaptive UI extension.
  </footer>

</body>
</html>
